---
export interface Props {
  question: any;
  sectionId: string;
}

const { question, sectionId } = Astro.props;

// Parse flat details array into nested sections based on colon pattern
function parseDetailsIntoSections(details: string[]): Array<{header: string, items: string[]}> {
  const sections: Array<{header: string, items: string[]}> = [];
  let currentSection: {header: string, items: string[]} | null = null;
  
  details.forEach(item => {
    // Remove leading bullet and trim
    const cleanItem = item.replace(/^•\s*/, '').trim();
    
    // Enhanced colon detection - check for patterns like:
    // - "text:"
    // - "**text:**" 
    // - "**text:** something else"
    // - "• **text:**"
    const colonPatterns = [
      /^(.+):$/, // Simple "text:"
      /^\*\*(.+):\*\*$/, // "**text:**"
      /^\*\*(.+):\*\*\s+/, // "**text:** more text"
      /^(.+):\s*$/ // "text: " with trailing space
    ];
    
    let isHeader = false;
    for (const pattern of colonPatterns) {
      if (pattern.test(cleanItem)) {
        isHeader = true;
        break;
      }
    }
    
    if (isHeader) {
      // New section header
      if (currentSection) {
        sections.push(currentSection); // Save previous section
      }
      currentSection = {
        header: cleanItem,
        items: []
      };
    } else {
      // Add to current section or create standalone item
      if (currentSection) {
        currentSection.items.push(cleanItem);
      } else {
        // Item without a header - treat as standalone
        sections.push({ header: '', items: [cleanItem] });
      }
    }
  });
  
  // Don't forget the last section
  if (currentSection) {
    sections.push(currentSection);
  }
  
  return sections;
}

// Simple markdown to HTML converter for basic formatting
function processMarkdown(text: string): string {
  if (!text) return '';
  
  return text
    // Remove leading bullets since we handle them with CSS
    .replace(/^•\s*/, '')
    // Bold text: **text** -> <strong>text</strong>
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    // Links: [text](url) -> <a href="url">text</a>
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>')
    // Code/inline code: `text` -> <code>text</code>
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    // Checkmarks and special bullets
    .replace(/✓/g, '✓')
    // Line breaks
    .replace(/\n/g, '<br/>');
}
---

<details class="faq-item" id={`${sectionId}-${question.id}`}>
  <summary class="faq-summary">
    <h3 class="faq-question">
      {question.question}
      <button class="question-permalink" onclick={`navigator.clipboard.writeText(window.location.origin + window.location.pathname + '#${sectionId}-${question.id}'); this.textContent = '✓ Copied!'; setTimeout(() => this.textContent = '#', 2000)`}>
        #
      </button>
    </h3>
    <svg class="faq-caret" width="20" height="20" viewBox="0 0 20 20" fill="none">
      <path d="M7.5 5L12.5 10L7.5 15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </summary>
  <div class="faq-answer">
    {question.answer.summary && (
      <p class="answer-summary" set:html={processMarkdown(question.answer.summary)}></p>
    )}
    
    {question.answer.timeline && Array.isArray(question.answer.timeline) && (
      <div class="timeline-list">
        {question.answer.timeline.map((timelineItem: any) => (
          <div class="timeline-item">
            <div class="timeline-header">
              <strong class="timeline-time">{timelineItem.time}</strong>
              <span class="timeline-event" set:html={processMarkdown(timelineItem.event)}></span>
            </div>
            {timelineItem.details && timelineItem.details.length > 0 && (
              <ul class="timeline-details">
                {timelineItem.details.map((detail: string) => (
                  <li set:html={processMarkdown(detail)}></li>
                ))}
              </ul>
            )}
          </div>
        ))}
      </div>
    )}
    
    {question.answer.sections && Array.isArray(question.answer.sections) && (
      <div class="answer-sections">
        {question.answer.sections.map((section: any) => (
          <div class="answer-section">
            <h4 class="section-header" set:html={processMarkdown(section.header)}></h4>
            <ul class="section-items">
              {section.items.map((item: string) => (
                <li set:html={processMarkdown(item)}></li>
              ))}
            </ul>
          </div>
        ))}
      </div>
    )}

    {question.answer.details && Array.isArray(question.answer.details) && (
      <div class="answer-sections">
        {parseDetailsIntoSections(question.answer.details).map((section) => (
          <div class="answer-section">
            {section.header && (
              <h4 class="section-header" set:html={processMarkdown(section.header)}></h4>
            )}
            <ul class={section.header ? "section-items" : "answer-list"}>
              {section.items.map((item: string) => (
                <li set:html={processMarkdown(item)}></li>
              ))}
            </ul>
          </div>
        ))}
      </div>
    )}
    
    {question.answer.proof && (
      <p class="answer-proof" set:html={processMarkdown(question.answer.proof)}></p>
    )}
  </div>
</details>

<style>
/* Remove webkit marker */
.faq-summary::-webkit-details-marker {
  display: none;
}

/* Question container for permalink */
.faq-question {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  margin: 0;
  font-size: var(--text-h4);
  font-weight: 500;
  color: var(--text-primary);
  line-height: 1.4;
  font-family: var(--font-body);
}

/* Summary styling with increased padding */
.faq-summary {
  list-style: none;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 0; /* Increased by 6px from 14px to 20px */
  user-select: none;
  transition: all 180ms ease;
}

.faq-summary::-webkit-details-marker {
  display: none;
}

.faq-summary:hover .faq-question {
  color: var(--brand-primary);
}

/* Caret icon */
.faq-caret {
  flex-shrink: 0;
  color: var(--text-muted);
  transition: transform 180ms ease;
}

.faq-item[open] .faq-caret {
  transform: rotate(90deg);
}

/* Open state with reduced border radius */
.faq-item[open] {
  background: var(--bg-secondary);
  border-radius: 8px; /* Reduced border radius for enterprise feel */
  padding: 24px;
  margin: 0 -24px;
  border: 1px solid var(--border-light);
}

/* Answer content */
.faq-answer {
  margin-top: 24px;
  color: var(--text-secondary);
  font-size: var(--text-body);
  line-height: var(--leading-relaxed);
}

/* Markdown formatting styles */
.faq-answer strong {
  color: var(--text-primary);
  font-weight: 600;
}

.faq-answer code {
  background: var(--bg-secondary);
  padding: 2px 6px;
  border-radius: 4px;
  font-family: var(--font-mono);
  font-size: 0.9em;
  color: var(--text-primary);
}

.faq-answer a {
  color: var(--brand-primary);
  text-decoration: none;
  font-weight: 500;
}

.faq-answer a:hover {
  text-decoration: underline;
}

/* Timeline formatting */
.timeline-list {
  margin: 16px 0;
}

.timeline-item {
  margin-bottom: 20px;
}

.timeline-item:last-child {
  margin-bottom: 0;
}

.timeline-header {
  margin-bottom: 8px;
}

.timeline-time {
  color: var(--brand-primary);
  font-weight: 600;
  margin-right: 8px;
}

.timeline-event {
  color: var(--text-primary);
  font-weight: 500;
}

.timeline-details {
  list-style: none;
  padding: 0;
  margin: 8px 0 0 0;
  padding-left: 20px;
}

.timeline-details li {
  position: relative;
  padding-left: 8px;
  margin: 6px 0;
  line-height: 1.6;
  color: var(--text-secondary);
}

.timeline-details li::before {
  content: "•";
  position: absolute;
  left: -16px;
  color: var(--brand-primary);
  font-weight: bold;
}

/* Nested sections formatting */
.answer-sections {
  margin: 16px 0;
}

.answer-section {
  margin-bottom: 20px;
}

.answer-section:last-child {
  margin-bottom: 0;
}

.section-header {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
  margin: 0 0 8px 0;
  line-height: 1.4;
}

.section-items {
  list-style: none;
  padding: 0;
  margin: 0;
  padding-left: 20px;
}

.section-items li {
  position: relative;
  padding-left: 8px;
  margin: 6px 0;
  line-height: 1.6;
  color: var(--text-secondary);
}

.section-items li::before {
  content: "•";
  position: absolute;
  left: -16px;
  color: var(--brand-primary);
  font-weight: bold;
}
</style>